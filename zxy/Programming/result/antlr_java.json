{"XPathWildcardElement":{"XPathWildcardElement":{}},"IterativeParseTreeWalker":{"IterativeParseTreeWalker":{}},"ATNSerializer":{"ATNSerializer":{"serialize":"Serialize state descriptors, edge descriptors, and decision&rarr;state map into list of ints: grammar-type, (ANTLRParser","getSerializedAsString":"Used by Java target to encode shortint array as chars in string"}},"SetTransition":{"SetTransition":{}},"BasicState":{"BasicState":{}},"Token":{"Token":{"getStopIndex":"The last character index of the token","getType":"Get the token type of the token  ","getChannel":"Return the channel this token","getStartIndex":"The starting character index of the token This method is optional; return -1 if not implemented","getText":"Get the text of the token","getCharPositionInLine":"The index of the first character of this token relative to the beginning of the line at which it occurs, 0","getLine":"The line number on which the 1st character of this token was matched, line=1","getTokenIndex":"An index from 0","getTokenSource":"Gets the   which created this token","getInputStream":"Gets the   from which this token was derived"}},"RangeTransition":{"RangeTransition":{}},"ErrorNodeImpl":{"ErrorNodeImpl":{}},"XPathTokenAnywhereElement":{"XPathTokenAnywhereElement":{}},"StarLoopEntryState":{"StarLoopEntryState":{}},"LexerIndexedCustomAction":{"LexerIndexedCustomAction":{"getActionType":"This method returns the result of calling on the   returned by ","LexerIndexedCustomAction":"Constructs a new indexed custom action by associating a character offset with a  ","getOffset":"Gets the location in the input   at which the lexeraction should be executed","getAction":"Gets the lexer action to execute","isPositionDependent":"This method returns ","execute":"This method calls   on the result of using the provided  "}},"BufferedTokenStream":{"BufferedTokenStream":{"getText":"Get the text of all tokens in this buffer","getTokens":"Given a start and stop index, return a List of all tokens in the token type BitSet","getHiddenTokensToLeft":"Collect all hidden tokens (any off-default channel) to the left of the current token up until we see a token on DEFAULT_TOKEN_CHANNEL","fill":"Get all tokens from lexer until EOF  ","sync":"Make sure index   in tokens has a token","adjustSeekIndex":"Allowed derived classes to modify the behavior of operations which change the current stream position by adjusting the target token index of a seek operation","fetch":"Add   elements to buffer","get":"Get all tokens from start","reset":"This method resets the token stream back to the first token in the buffer","getHiddenTokensToRight":"Collect all hidden tokens (any off-default channel) to the right of the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or EOF","setTokenSource":"Reset this token stream by setting its token source","nextTokenOnChannel":"Given a starting index, return the index of the next token on channel","previousTokenOnChannel":"Given a starting index, return the index of the previous token on channel"}},"ATNSimulator":{"ATNSimulator":{"toUUID":"Use  instead","edgeFactory":"Use  instead","toInt":"Use  instead","toLong":"Use  instead","toInt32":"Use  instead","checkCondition":"Use  instead","stateFactory":"Use  instead","clearDFA":"Clear the DFA cache used by the current instance","deserialize":"Use  instead"}},"LexerActionExecutor":{"LexerActionExecutor":{"fixOffsetBeforeMatch":"Creates a   which encodes the current offsetfor position-dependent lexer actions","LexerActionExecutor":"Constructs an executor for a sequence of   actions","getLexerActions":"Gets the lexer actions to be executed by this executor","execute":"Execute the actions encapsulated by this executor within the context of a particular  ","append":"Creates a   which executes the actions forthe input   followed by a specified"}},"ErrorNode":{"ErrorNode":{}},"AbstractPredicateTransition":{"AbstractPredicateTransition":{}},"CodePointCharStream":{"CodePointCharStream":{"getText":"Return the UTF-16 encoded string for the given interval  ","fromBuffer":"Constructs a named   which provides accessto the Unicode code points stored in  ","mark":"markrelease do nothing; we have entire buffer  "}},"ATNDeserializationOptions":{"ATNDeserializationOptions":{}},"LexerChannelAction":{"LexerChannelAction":{"getActionType":"This method returns ","LexerChannelAction":"Constructs a new   action with the specified channel value","getChannel":"Gets the channel to use for the   created by the lexer","isPositionDependent":"This method returns ","execute":"This action is implemented by calling   with thevalue provided by  "}},"PredicateTransition":{"PredicateTransition":{}},"PredicateEvalInfo":{"PredicateEvalInfo":{"PredicateEvalInfo":"Constructs a new instance of the   class with thespecified detailed predicate evaluation information"}},"TextChunk":{"TextChunk":{"getText":"Gets the raw text of this chunk","TextChunk":"Constructs a new instance of   with the specified text","toString":"The implementation for   returns the result of in single quotes"}},"DecisionState":{"DecisionState":{}},"InputMismatchException":{"InputMismatchException":{}},"SingletonPredictionContext":{"SingletonPredictionContext":{}},"LexerDFASerializer":{"LexerDFASerializer":{}},"Parser":{"Parser":{"setTrace":"During a parse is sometimes useful to listen in on the rule entry and exit events as well as token matches","getBuildParseTree":"Gets whether or not a complete parse tree will be constructed while parsing","dumpDFA":"For debugging and other purposes","createErrorNode":"How to create an error node, given a token, associated with a parent","getRuleIndex":"Get a rule's index (i","getPrecedence":"Get the precedence level for the top-most precedence rule","createTerminalNode":"How to create a token leaf node associated with a parent","pushNewRecursionContext":"Like   but for recursive rules","consume":"Consume and return the  ","triggerExitRuleEvent":"Notify any parse listeners of an exit rule event","compileParseTreePattern":"The same as   but specify a rather than trying to deduce it from this parser","getCurrentToken":"Match needs to return the current input symbol, which gets put into the label for the associated token ref; e","setTokenStream":"Set the token stream and reset the parser","getATNWithBypassAlts":"The ATN with bypass alternatives is expensive to create so we create it lazily","isExpectedToken":"Checks whether or not   can follow the current state in theATN","setTrimParseTree":"Trim the internal lists of the parse tree during parsing to conserve memory","removeParseListeners":"Remove all parse listeners","matchWildcard":"Match current input symbol as a wildcard","getExpectedTokens":"Computes the set of input symbols which could follow the current parser state and context, as given by   and , respectively","getTrimParseTree":"if the  list is trimmedusing the default   during the parse process","match":"Match current input symbol against  ","setTokenFactory":"Tell our token source and error strategy about a new way to create tokens","getRuleInvocationStack":"Return List&lt;String&gt; of the rule names in your parser instance leading up to a call to the current rule","setBuildParseTree":"Track the   objects during the parse and hookthem up using the   list so that itforms a parse tree","setProfile":"4","addParseListener":"Registers   to receive events during the parsing process","enterRule":"Always called by generated parsers upon entry to a rule","enterRecursionRule":"Use instead","removeParseListener":"Remove   from the list of parse listeners","reset":"reset the parser's state  ","getDFAStrings":"For debugging and other purposes","isTrace":"Gets whether a   is registered as a parse listenerfor the parser","triggerEnterRuleEvent":"Notify any parse listeners of an enter rule event","getNumberOfSyntaxErrors":"Gets the number of syntax errors reported during parsing"}},"TokenStreamRewriter":{"TokenStreamRewriter":{"rollback":"Rollback the instruction stream for a program so that the indicated instruction (via instructionIndex) is no longer in the stream","deleteProgram":"Reset the program so that no instructions exist  ","getText":"Return the text associated with the tokens in the interval from the original token stream but with the alterations given to this rewriter","reduceToSingleOperationPerIndex":"We need to combine operations and report invalid operations (like overlapping replaces that are not completed nested)","execute":"Execute the rewrite operation by possibly adding to the buffer","getKindOfOps":"Get all operations before an index of a particular kind  "}},"ParseTreeListener":{"ParseTreeListener":{}},"CodePointBuffer":{"CodePointBuffer":{}},"PlusBlockStartState":{"PlusBlockStartState":{}},"DiagnosticErrorListener":{"DiagnosticErrorListener":{"DiagnosticErrorListener":"Initializes a new instance of  , specifying whether all ambiguities or only exact ambiguities are reported","getConflictingAlts":"Computes the set of conflicting or ambiguous alternatives from a configuration set, if that information was not already provided by the parser"}},"ActionTransition":{"ActionTransition":{}},"IntervalSet":{"IntervalSet":{"add":"Add interval; i","or":"combine all sets in the array returned the or'd value  ","subtract":"Compute the set difference between two interval sets","elementName":"Use  instead","contains":"     ","getMaxElement":"Returns the maximum value contained in the set if not isNil()","getIntervals":"Return a list of Interval objects","getMinElement":"Returns the minimum value contained in the set if not isNil()","and":"     ","of":"Create a set with all ints within range [a","equals":"Are two IntervalSets equal?  Because all intervals are sorted and disjoint, equals is a simple linear walk over both lists to make sure they are the same","get":"Get the ith element of ordered set","isNil":"     ","toString":"Use  instead","complement":"     "}},"NotSetTransition":{"NotSetTransition":{}},"LexerATNSimulator":{"LexerATNSimulator":{"getReachableConfigSet":"Given a starting configuration set, figure out all ATN configurations we can reach upon input  ","evaluatePredicate":"Evaluate a predicate specified in the lexer","getText":"Get the text matched so far for the current token","computeTargetState":"Compute a target state for an edge in the DFA, and attempt to add the computed state and corresponding edge to the DFA","getExistingTargetState":"Get an existing target state for an edge in the DFA","addDFAState":"Add a new DFA state if there isn't one with this set of configurations already","closure":"Since the alternatives within any lexer decision are ordered by preference, this method stops pursuing the closure as soon as an accept state is reached"}},"ProfilingATNSimulator":{"ProfilingATNSimulator":{}},"BlockStartState":{"BlockStartState":{}},"Interval":{"Interval":{"startsAfter":"Does this","disjoint":"Are both ranges disjoint? I","of":"Interval objects are used readonly so share all with the same single value a==b up to some max size","intersection":"Return the interval in common between this and o  ","length":"return number of elements between a and b inclusively","startsBeforeDisjoint":"Does this start completely before other? Disjoint  ","adjacent":"Are two intervals adjacent such as 0","union":"Return the interval computed from combining this and other  ","startsAfterNonDisjoint":"Does this start after other? NonDisjoint  ","differenceNotProperlyContained":"Return the interval with elements from this not in other; other must not be totally enclosed (properly contained) within this, which would result in two disjoint intervals instead of the single one returned by this method","startsBeforeNonDisjoint":"Does this start at or before other? Nondisjoint  ","startsAfterDisjoint":"Does this start completely after other? Disjoint  "}},"WritableToken":{"WritableToken":{}},"StarLoopbackState":{"StarLoopbackState":{}},"InterpreterDataReader":{"InterpreterDataReader":{"parseFile":"The structure of the data file is very simple"}},"LexerTypeAction":{"LexerTypeAction":{"getActionType":"This method returns ","getType":"Gets the type to assign to a token created by the lexer","LexerTypeAction":"Constructs a new   action with the specified token type value","isPositionDependent":"This method returns ","execute":"This action is implemented by calling   with thevalue provided by  "}},"BasicBlockStartState":{"BasicBlockStartState":{}},"AbstractParseTreeVisitor":{"AbstractParseTreeVisitor":{"visitErrorNode":"The default implementation returns the result of ","aggregateResult":"Aggregates the results of visiting multiple children of a node","visitTerminal":"The default implementation returns the result of ","visit":"The default implementation calls   on thespecified tree","defaultResult":"Gets the default value returned by visitor methods","visitChildren":"The default implementation initializes the aggregate result to ","shouldVisitNextChild":"This method is called after visiting each child in "}},"PredictionContextCache":{"PredictionContextCache":{"add":"Add a context to the cache and return it"}},"PredictionMode":{"PredictionMode":{"hasConfigInRuleStopState":"Checks if any configuration in   is in a","hasSLLConflictTerminatingPrediction":"Computes the SLL prediction termination condition","hasNonConflictingAltSet":"Determines if any single alternative subset in   containsexactly one alternative","getConflictingAltSubsets":"This function gets the conflicting alt subsets from a configuration set","allSubsetsConflict":"Determines if every alternative subset in   contains morethan one alternative","getUniqueAlt":"Returns the unique alternative predicted by all alternative subsets in ","hashCode":"The hash code is only a function of the  and  ","resolvesToJustOneViableAlt":"Full LL prediction termination","allSubsetsEqual":"Determines if every alternative subset in   is equivalent","hasConflictingAltSet":"Determines if any single alternative subset in   containsmore than one alternative","getStateToAltMap":"Get a map from state to alt subset from a configuration set","allConfigsInRuleStopStates":"Checks if all configurations in   are in a","getAlts":"Get union of all alts from configs"}},"ATNState":{"ATNState":{}},"MultiMap":{"MultiMap":{}},"ParseTreeVisitor":{"ParseTreeVisitor":{"visitErrorNode":"Visit an error node, and return a user-defined result of the operation","visitTerminal":"Visit a terminal node, and return a user-defined result of the operation","visit":"Visit a parse tree, and return a user-defined result of the operation","visitChildren":"Visit the children of a node, and return a user-defined result of the operation"}},"RuntimeMetaData":{"RuntimeMetaData":{"getMajorMinorVersion":"Gets the major and minor version numbers from a version string","checkVersion":"This method provides the ability to detect mismatches between the version of ANTLR 4 used to generate a parser, the version of the ANTLR runtime a parser was compiled against, and the version of the ANTLR runtime which is currently executing","getRuntimeVersion":"Gets the currently executing version of the ANTLR 4 runtime library"}},"FailedPredicateException":{"FailedPredicateException":{}},"ObjectEqualityComparator":{"ObjectEqualityComparator":{"hashCode":"This implementation returns ","equals":"This implementation relies on object equality"}},"ParseTreeWalker":{"ParseTreeWalker":{"enterRule":"The discovery of a rule node, involves sending two events: the generic  and a-specific event"}},"XPath":{"XPath":{"getXPathElement":"Convert word like   or  or  to a pathelement","evaluate":"Return a list of all nodes starting at   as root that satisfy thepath"}},"TokenSource":{"TokenSource":{"getSourceName":"Gets the name of the underlying input source","getTokenFactory":"Gets the   this token source is currently using forcreating   objects from the input","nextToken":"Return a   object from your input stream (usually a)","getCharPositionInLine":"Get the index into the current line for the current position in the input stream","getLine":"Get the line number for the current position in the input stream","setTokenFactory":"Set the   this token source should use for creating objects from the input","getInputStream":"Get the   from which this token source is currentlyproviding tokens"}},"RuleStopState":{"RuleStopState":{}},"BailErrorStrategy":{"BailErrorStrategy":{"recover":"Instead of recovering from exception  , re-throw it wrapped in a   so it is not caught by therule function catches","sync":"Make sure we don't attempt to recover from problems in subrules","recoverInline":"Make sure we don't attempt to recover inline; if the parser successfully recovers, it won't throw an exception"}},"RuleNode":{"RuleNode":{}},"ParseTreePattern":{"ParseTreePattern":{"getPatternRuleIndex":"Get the parser rule which serves as the outermost rule for the tree pattern","getMatcher":"Get the   which created this tree pattern","match":"Match a specific parse tree against this tree pattern","ParseTreePattern":"Construct a new instance of the   class","getPattern":"Get the tree pattern in concrete syntax form","matches":"Determine whether or not a parse tree matches this tree pattern","findAll":"Find all nodes using XPath and then try to match those subtrees against this tree pattern","getPatternTree":"Get the tree pattern as a  "}},"ATNType":{"ATNType":{}},"XPathElement":{"XPathElement":{"XPathElement":"Construct element like   or  or  etc","evaluate":"Given tree rooted at   return all nodes matched by this pathelement"}},"TerminalNodeImpl":{"TerminalNodeImpl":{}},"ContextSensitivityInfo":{"ContextSensitivityInfo":{"ContextSensitivityInfo":"Constructs a new instance of the   classwith the specified detailed context sensitivity information"}},"ParseTreeMatch":{"ParseTreeMatch":{"getMismatchedNode":"Get the node at which we first detected a mismatch","getTree":"Get the parse tree we are trying to match to a pattern","getLabels":"Return a mapping from label &rarr; [list of nodes]","getAll":"Return all nodes matching a rule or token tag with the specified label","get":"Get the last node associated with a specific  ","toString":"    ","getPattern":"Get the tree pattern we are matching against","ParseTreeMatch":"Constructs a new instance of   from the specifiedparse tree and pattern","succeeded":"Gets a value indicating whether the match operation succeeded"}},"DFASerializer":{"DFASerializer":{"DFASerializer":"Use  instead"}},"XPathRuleElement":{"XPathRuleElement":{}},"CharStreams":{"CharStreams":{"fromPath":"Creates a   given a path to a file on disk and thecharset of the bytes contained in the file","fromStream":"Creates a   given an opened  and thecharset of the bytes contained in the stream","fromChannel":"Creates a   given an opened containing UTF-8 bytes","fromFileName":"Creates a   given a string containing apath to a file on disk and the charset of the bytes contained in the file","fromString":"Creates a   given a  and the from which it came","fromReader":"Creates a   given a  and itssource name"}},"CodePointTransitions":{"CodePointTransitions":{"createWithCodePoint":"If   is <= U+FFFF, returns a new ","createWithCodePointRange":"If   and  are both<= U+FFFF, returns a new  "}},"LexerPopModeAction":{"LexerPopModeAction":{"getActionType":"This method returns ","isPositionDependent":"This method returns ","execute":"This action is implemented by calling  ","LexerPopModeAction":"Constructs the singleton instance of the lexer   command"}},"LexerPushModeAction":{"LexerPushModeAction":{"LexerPushModeAction":"Constructs a new   action with the specified mode value","getActionType":"This method returns ","getMode":"Get the lexer mode this action should transition the lexer to","isPositionDependent":"This method returns ","execute":"This action is implemented by calling   with thevalue provided by  "}},"XPathLexer":{"XPathLexer":{}},"TokensStartState":{"TokensStartState":{}},"Utils":{"Utils":{"sequence":"4","expandTabs":"4","newlines":"4","toMap":"Convert array of strings to string&rarr;index map","spaces":"4","count":"4"}},"ParseCancellationException":{"ParseCancellationException":{}},"XPathWildcardAnywhereElement":{"XPathWildcardAnywhereElement":{}},"Transition":{"Transition":{"isEpsilon":"Determines if the transition is an \"epsilon\" transition"}},"ListTokenSource":{"ListTokenSource":{"getSourceName":"    ","getTokenFactory":"    ","nextToken":"    ","getCharPositionInLine":"    ","getLine":"    ","setTokenFactory":"    ","ListTokenSource":"Constructs a new   instance from the specifiedcollection of   objects and source name","getInputStream":"    "}},"UnbufferedCharStream":{"UnbufferedCharStream":{"release":"Decrement number of markers, resetting buffer if we hit 0","nextChar":"Override to provide different source of characters than ","UnbufferedCharStream":"Useful for subclasses that pull char from other than this","fill":"Add   characters to the buffer","sync":"Make sure we have 'need' elements from current position  ","seek":"Seek to absolute character index, which might not be in the current sliding window","mark":"Return a marker that we can release later"}},"ATN":{"ATN":{"getExpectedTokens":"Computes the set of input symbols which could follow ATN state number  in the specified full ","ATN":"Used for runtime deserialization of ATNs from strings  ","nextTokens":"Compute the set of valid tokens that can occur starting in   andstaying in same rule"}},"DoubleKeyMap":{"DoubleKeyMap":{"values":"Get all values associated with primary key  ","keySet":"get all secondary keys associated with a primary key  "}},"ATNConfigSet":{"ATNConfigSet":{"add":"Adding a new config means merging contexts with existing configs for , where   is the,   is the , and  is the ","elements":"Return a List holding list of configs  ","getAlts":"Gets the complete set of represented alternatives for the configuration set"}},"Vocabulary":{"Vocabulary":{"getDisplayName":"Gets the display name of a token type","getLiteralName":"Gets the string literal associated with a token type","getSymbolicName":"Gets the symbolic name associated with a token type","getMaxTokenType":"Returns the highest token type value"}},"XPathRuleAnywhereElement":{"XPathRuleAnywhereElement":{}},"ParserInterpreter":{"ParserInterpreter":{"ParserInterpreter":"Use  instead","recover":"Rely on the error handler for this parser but, if no tokens are consumed to recover, add an error node","visitDecisionState":"Method visitDecisionState() is called when the interpreter reaches a decision state (instance of DecisionState)","parse":"Begin parsing at startRuleIndex  ","addDecisionOverride":"Override this parser interpreters normal decision-making process at a particular decision and input token index","getRootContext":"Return the root of the parse, which can be useful if the parser bails out","createInterpreterRuleContext":"Provide simple \"factory\" for InterpreterRuleContext's"}},"RuleContext":{"RuleContext":{"getText":"Return the combined text of all child nodes","getAltNumber":"For rule associated with this parse tree internal node, return the outer alternative number used to match the input","isEmpty":"A context is empty if there is no invoking state; meaning nobody called current context","setParent":"4","toStringTree":"Print out a whole tree, not just a node, in LISP format (root child1 ","setAltNumber":"Set the outer alternative number for this context node"}},"AtomTransition":{"AtomTransition":{}},"WildcardTransition":{"WildcardTransition":{}},"PlusLoopbackState":{"PlusLoopbackState":{}},"OrderedATNConfigSet":{"OrderedATNConfigSet":{}},"CharStream":{"CharStream":{"getText":"This method returns the text for a range of characters within this input stream"}},"Predicate":{"Predicate":{}},"ATNConfig":{"ATNConfig":{"equals":"An ATN configuration is equal to another if both have the same state, they predict the same alternative, and syntacticsemantic contexts are the same","getOuterContextDepth":"This method gets the value of the   fieldas it existed prior to the introduction of the  method"}},"TestRig":{"TestRig":{}},"ArrayPredictionContext":{"ArrayPredictionContext":{}},"DefaultErrorStrategy":{"DefaultErrorStrategy":{"singleTokenInsertion":"This method implements the single-token insertion inline error recovery strategy","recover":"The default implementation resynchronizes the parser by consuming tokens until we find one in the resynchronization set--loosely the set of tokens that can follow the current rule","inErrorRecoveryMode":"    ","reportError":"The default implementation returns immediately if the handler is already in error recovery mode","beginErrorCondition":"This method is called to enter error recovery mode when a recognition exception is reported","sync":"The default implementation of   makes surethat the current lookahead symbol is consistent with what were expecting at this point in the ATN","reportNoViableAlternative":"This is called by   when the exception is a","reportMissingToken":"This method is called to report a syntax error which requires the insertion of a missing token into the input stream","recoverInline":"The default implementation attempts to recover from the mismatched input by using single token insertion and deletion as described below","singleTokenDeletion":"This method implements the single-token deletion inline error recovery strategy","getTokenErrorDisplay":"How should a token be displayed in an error message? The default is to display just the text, but during development you might want to have a lot of information spit out","endErrorCondition":"This method is called to leave error recovery mode after recovering from a recognition exception","reportUnwantedToken":"This method is called to report a syntax error which requires the removal of a token from the input stream","reportMatch":"The default implementation simply calls  ","consumeUntil":"Consume tokens until one matches the given token set","reset":"The default implementation simply calls   toensure that the handler is not in error recovery mode","getMissingSymbol":"Conjure up a missing token during error recovery","reportInputMismatch":"This is called by   when the exception is an","reportFailedPredicate":"This is called by   when the exception is a"}},"LexerNoViableAltException":{"LexerNoViableAltException":{}},"NoViableAltException":{"NoViableAltException":{}},"LexerMoreAction":{"LexerMoreAction":{"getActionType":"This method returns ","LexerMoreAction":"Constructs the singleton instance of the lexer   command","isPositionDependent":"This method returns ","execute":"This action is implemented by calling  "}},"Tree":{"Tree":{"getChildCount":"How many children are there? If there is none, then this node represents a leaf node","getPayload":"This method returns whatever object represents the data at this note","getParent":"The parent of this node","getChild":"If there are children, get the  th value indexed from 0","toStringTree":"Print out a whole tree, not just a node, in LISP format "}},"EmptyPredictionContext":{"EmptyPredictionContext":{}},"XPathLexerErrorListener":{"XPathLexerErrorListener":{}},"Trees":{"Trees":{"getAncestors":"Return a list of all ancestors of this node","isAncestorOf":"Return true if t is u's parent or a node on path to root from u","getChildren":"Return ordered list of all children of this node  ","getDescendants":"Get all descendents; includes t itself","findNodeSuchThat":"Return first node satisfying the pred   4","stripChildrenOutOfRange":"Replace any subtree siblings of root that are completely to left or right of lookahead range with a CommonToken(Token","getRootOfSubtreeEnclosingRegion":"Find smallest subtree of t enclosing range startTokenIndex","toStringTree":"Print out a whole tree in LISP form","descendants":"     "}},"StarBlockStartState":{"StarBlockStartState":{}},"ParserRuleContext":{"ParserRuleContext":{"addErrorNode":"Add a child to this node based upon badToken","getStart":"Get the initial token in this context","addAnyChild":"Add a parse tree node to this as a child","addChild":"Add a child to this node based upon matchedToken","getStop":"Get the final token in this context","toInfoString":"Used for rule context info debugging during parse-time, not so much for ATN debugging  ","copyFrom":"COPY a ctx (I'm deliberately not using copy constructor) to avoid confusion with creating node with parent","removeLastChild":"Used by enterOuterAlt to toss out a RuleContext previously added as we entered a rule"}},"CommonTokenFactory":{"CommonTokenFactory":{"CommonTokenFactory":"Constructs a   with  set to"}},"InterpreterRuleContext":{"InterpreterRuleContext":{"InterpreterRuleContext":"Constructs a new   with the specifiedparent, invoking state, and rule index"}},"DFAState":{"DFAState":{"equals":"Two   instances are equal if their ATN configuration setsare the same","getAltSet":"Get the set of all alts mentioned by all ATN configurations in this DFA state"}},"RuleTagToken":{"RuleTagToken":{"getLabel":"Gets the label associated with the rule tag","getStopIndex":"The implementation for   always returns -1","RuleTagToken":"Constructs a new instance of   with the specified rulename, bypass token type, and label","getRuleName":"Gets the name of the rule associated with this rule tag","getStartIndex":"The implementation for   always returns -1","getText":"This method returns the rule tag formatted with   and delimiters","getCharPositionInLine":"The implementation for   always returns -1","getLine":"The implementation for   always returns 0","getInputStream":"The implementation for   always returns ","getChannel":"Rule tag tokens are always placed on the  ","getType":"Rule tag tokens have types assigned according to the rule bypass transitions created during ATN deserialization","toString":"The implementation for   returns a string of the form","getTokenIndex":"The implementation for   always returns -1","getTokenSource":"The implementation for   always returns "}},"BaseErrorListener":{"BaseErrorListener":{}},"LexerAction":{"LexerAction":{"getActionType":"Gets the serialization type of the lexer action","isPositionDependent":"Gets whether the lexer action is position-dependent","execute":"Execute the lexer action in the context of the specified  "}},"ErrorInfo":{"ErrorInfo":{"ErrorInfo":"Constructs a new instance of the   class with thespecified detailed syntax error information"}},"AmbiguityInfo":{"AmbiguityInfo":{"AmbiguityInfo":"Constructs a new instance of the   class with thespecified detailed ambiguity information"}},"Chunk":{"Chunk":{}},"LexerActionType":{"LexerActionType":{}},"Triple":{"Triple":{}},"LexerSkipAction":{"LexerSkipAction":{"LexerSkipAction":"Constructs the singleton instance of the lexer   command","getActionType":"This method returns ","isPositionDependent":"This method returns ","execute":"This action is implemented by calling  "}},"LexerInterpreter":{"LexerInterpreter":{}},"Lexer":{"Lexer":{"getTokenNames":"Used to print out token names like ID during debugging and error reporting","recover":"Lexers can normally match any char in it's vocabulary after matching a token, so do the easy thing and just kill a character and hope it all works out","getAllTokens":"Return a list of all Token objects in input char stream","nextToken":"Return a token from this source; i","setInputStream":"Set the char stream and reset the lexer  ","getText":"Return the text matched so far for the current token or any text override","getToken":"Override if emitting multiple tokens","skip":"Instruct the lexer to skip creating a token for current lexer rule and look for another token","emit":"The standard method called to automatically emit a token at the outermost lexical rule","getCharIndex":"What is the index of the current character of lookahead?  ","setText":"Set the complete text of this token; it wipes any previous changes to the text"}},"MurmurHash":{"MurmurHash":{"hashCode":"Utility function to compute the hash code of an array using the MurmurHash algorithm","update":"Update the intermediate hash value for the next input  ","finish":"Apply the final computation steps to the intermediate value  to form the final result of the MurmurHash 3 hash function","initialize":"Initialize the hash using the specified  "}},"Recognizer":{"Recognizer":{"getRuleIndexMap":"Get a map from rule names to rule indexes","getInterpreter":"Get the ATN interpreter used by the recognizer for prediction","getVocabulary":"Get the vocabulary used by the recognizer","getATN":"Get the   used by the recognizer for prediction","getParseInfo":"If profiling during the parselex, this will return DecisionInfo records for each decision in recognizer in a ParseInfo object","getTokenNames":"Used to print out token names like ID during debugging and error reporting","getSerializedATN":"If this recognizer was generated, it will have a serialized ATN representation of the grammar","getTokenErrorDisplay":"How should a token be displayed in an error message? The default is to display just the text, but during development you might want to have a lot of information spit out","getTokenTypeMap":"Get a map from token names to token types","addErrorListener":"NullPointerException if  is ","setInterpreter":"Set the ATN interpreter used by the recognizer for prediction","setState":"Indicate that the recognizer has changed internal state that is consistent with the ATN state passed in","getGrammarFileName":"For debugging and other purposes, might want the grammar name","getErrorHeader":"What is the error header, normally linecharacter position information?  "}},"Array2DHashSet":{"Array2DHashSet":{"asElementType":"Return   as an instance of the element type ","getOrAdd":"Add   to set if not there; return existing value if alreadythere","createBucket":"Return an array of   with length ","createBuckets":"Return an array of   with length "}},"SemanticContext":{"SemanticContext":{"evalPrecedence":"Evaluate the precedence predicates for the context and reduce the result","eval":"The evaluation of predicates by this context is short-circuiting, but unordered","or":"ParserATNSimulator#getPredsForAmbigAlts ","getOperands":"Gets the operands for the semantic context operator"}},"RuleTransition":{"RuleTransition":{"RuleTransition":"Use instead"}},"OrderedHashSet":{"OrderedHashSet":{"add":"Add a value to list; keep in hashtable for consistency also; Key is object itself","set":"Replace an existing value with a new value; updates the element list and the hash table, but not the key as that has not changed","elements":"Return the List holding list of table elements"}},"ParserATNSimulator":{"ParserATNSimulator":{"canDropLoopEntryEdgeInLeftRecursiveRule":"Implements first-edge (loop entry) elimination as an optimization during closure operations","dumpDeadEndConfigs":"Used for debugging in adaptivePredict around execATN but I cut it out for clarity now that alg","getConflictingAlts":"Gets a   containing the alternatives in which are part of one or more conflicting alternative subsets","applyPrecedenceFilter":"This method transforms the start state computed by  to the special start state used by aprecedence DFA for a particular precedence value","closure_":"Do the actual work of walking epsilon edges  ","addDFAEdge":"Add an edge to the DFA, if possible","getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule":"This method is used to improve the localization of error messages by choosing an alternative rather than throwing a  in particular prediction scenarios where the state was reached during ATN simulation","evalSemanticContext":"Evaluate a semantic context within a specific parser context","execATN":"Performs ATN simulation to compute a predicted alternative based upon the remaining input, but also updates the DFA cache to avoid having to traverse the ATN again for the same input sequence","removeAllConfigsNotInRuleStopState":"Return a configuration set containing only the configurations from  which are in a ","getConflictingAltsOrUniqueAlt":"Sam pointed out a problem with the previous definition, v3, of ambiguous states","computeTargetState":"Compute a target state for an edge in the DFA, and attempt to add the computed state and corresponding edge to the DFA","getParser":"4","getExistingTargetState":"Get an existing target state for an edge in the DFA","addDFAState":"Add state   to the DFA if it is not already present, and returnthe actual instance stored in the DFA","reportAmbiguity":"If context sensitive parsing, we know it's ambiguity not conflict  ","ParserATNSimulator":"Testing only!  ","splitAccordingToSemanticValidity":"Walk the list of configurations and split them according to those that have preds evaluating to truefalse"}},"CommonToken":{"CommonToken":{"CommonToken":"Constructs a new   as a copy of another ","setText":"Explicitly set the text for this token"}},"ANTLRInputStream":{"ANTLRInputStream":{"reset":"Reset the stream so that it's in the same state it was when the object was created except the data array is not touched","index":"Return the current input symbol index 0","seek":"consume() ahead until p==index; can't just set p=index as we must update line and charPositionInLine","ANTLRInputStream":"This is the preferred constructor for strings as no data is copied  ","mark":"markrelease do nothing; we have entire buffer  "}},"RecognitionException":{"RecognitionException":{"getExpectedTokens":"Gets the set of input symbols which could potentially follow the previously matched symbol at the time this exception was thrown","getRecognizer":"Gets the   where this exception occurred","getOffendingState":"Get the ATN state number the parser was in at the time the error occurred","getCtx":"Gets the   at the time this exception was thrown","getInputStream":"Gets the input stream which is the symbol source for the recognizer where this exception was thrown"}},"ATNDeserializer":{"ATNDeserializer":{"markPrecedenceDecisions":"Analyze the   states in the specified ATN to setthe   field to thecorrect value","isFeatureSupported":"Determines if a particular serialized representation of an ATN supports a particular feature, identified by the   used for serializingthe ATN at the time the feature was first introduced"}},"TokenStream":{"TokenStream":{"getText":"Return the text of all tokens in this stream between   and (inclusive)","get":"Gets the   at the specified  in the stream","LT":"Get the   instance associated with the value returned by","getTokenSource":"Gets the underlying   which provides tokens for thisstream"}},"SyntaxTree":{"SyntaxTree":{"getSourceInterval":"Return an   indicating the index in the of the first and last token associated with thissubtree"}},"IntSet":{"IntSet":{"add":"Adds the specified value to the current set","or":"Return a new   object containing all elements that arepresent in the current set, the specified set  , or both","subtract":"Return a new   object containing all elements that arepresent in the current set but not present in the input set  ","toList":"Return a list containing the elements represented by the current set","remove":"Removes the specified value from the current set","contains":"Returns   if the set contains the specified element","size":"Return the total number of elements represented by the current set","addAll":"Modify the current   object to contain all elements that arepresent in itself, the specified  , or both","and":"Return a new   object containing all elements that arepresent in both the current set and the specified set  ","equals":"    ","isNil":"Returns   if this set contains no elements","toString":"    ","complement":"Return a new   object containing all elements that arepresent in   but not present in the current set"}},"ParseTreePatternMatcher":{"ParseTreePatternMatcher":{"matchImpl":"Recursively walk   against , filling ","split":"Split   into 4 chunks for tokenizing by ","compile":"For repeated use of a tree pattern, compile it to a  using this method","getRuleTagToken":"Is    subtree?  ","ParseTreePatternMatcher":"Constructs a   or from a  and object","getParser":"Used to collect to the grammar file name, token names, rule names for used to parse the pattern into a parse tree","match":"Compare   matched against  and return a object that contains the matched elements, or thenode at which the match failed","getLexer":"Used to convert the tree pattern string into a series of tokens","matches":"Does   matched as rule patternRuleIndex match tree? Pass in acompiled pattern instead of a string representation of a tree pattern","setDelimiters":"Set the delimiters used for marking rule and token tags within concrete syntax used by the tree pattern parser"}},"PrecedencePredicateTransition":{"PrecedencePredicateTransition":{}},"TokenTagToken":{"TokenTagToken":{"getLabel":"Gets the label associated with the rule tag","getText":"The implementation for   returns the token tagformatted with   and  delimiters","getTokenName":"Gets the token name","TokenTagToken":"Constructs a new instance of   with the specifiedtoken name, type, and label","toString":"The implementation for   returns a string of the form"}},"ParseInfo":{"ParseInfo":{"getTotalSLLLookaheadOps":"Gets the total number of SLL lookahead operations across all decisions made during parsing","getDFASize":"Gets the total number of DFA states stored in the DFA cache for a particular decision","getTotalATNLookaheadOps":"Gets the total number of ATN lookahead operations for SLL and LL prediction across all decisions made during parsing","getTotalTimeInPrediction":"Gets the total time spent during prediction across all decisions made during parsing","getTotalLLATNLookaheadOps":"Gets the total number of ATN lookahead operations for LL prediction across all decisions made during parsing","getDecisionInfo":"Gets an array of   instances containing the profilinginformation gathered for each decision in the ATN","getTotalSLLATNLookaheadOps":"Gets the total number of ATN lookahead operations for SLL prediction across all decisions made during parsing","getTotalLLLookaheadOps":"Gets the total number of LL lookahead operations across all decisions made during parsing","getLLDecisions":"Gets the decision numbers for decisions that required one or more full-context predictions during parsing"}},"AbstractEqualityComparator":{"AbstractEqualityComparator":{}},"ANTLRErrorListener":{"ANTLRErrorListener":{"reportContextSensitivity":"This method is called by the parser when a full-context prediction has a unique result","syntaxError":"Upon syntax error, notify any interested parties","reportAmbiguity":"This method is called by the parser when a full-context prediction results in an ambiguity","reportAttemptingFullContext":"This method is called when an SLL conflict occurs and the parser is about to use the full context information to make an LL decision"}},"PredictionContext":{"PredictionContext":{"fromRuleContext":"Convert a   tree to a  graph","mergeRoot":"Handle case where at least one of   or  is","combineCommonParents":"Make pass over all <em>M<em>  ; merge any  ones","isEmpty":"This means only the   (wildcard? not sure) context is in set","mergeArrays":"Merge two   instances","mergeSingletons":"Merge two   instances"}},"NotNull":{"NotNull":{}},"UnbufferedTokenStream":{"UnbufferedTokenStream":{"fill":"Add   elements to the buffer","sync":"Make sure we have 'need' elements from current position  ","mark":"Return a marker that we can release later"}},"LookaheadEventInfo":{"LookaheadEventInfo":{"LookaheadEventInfo":"Constructs a new instance of the   class withthe specified detailed lookahead information"}},"TagChunk":{"TagChunk":{"TagChunk":"Construct a new instance of   using the specified labeland tag","getLabel":"Get the label, if any, assigned to this chunk","toString":"This method returns a text representation of the tag chunk","getTag":"Get the tag for this chunk"}},"ConsoleErrorListener":{"ConsoleErrorListener":{"syntaxError":"This implementation prints messages to   containing thevalues of  ,  , and   usingthe following format"}},"IntegerList":{"IntegerList":{"toCharArray":"Convert the list to a UTF-16 encoded char array","hashCode":"Returns the hash code value for this list","equals":"Compares the specified object with this list for equality","toString":"Returns a string representation of this list"}},"ANTLRErrorStrategy":{"ANTLRErrorStrategy":{"recover":"This method is called to recover from exception  ","reportMatch":"This method is called by when the parser successfully matches an input symbol","reset":"Reset the error handler state for the specified  ","inErrorRecoveryMode":"Tests whether or not   is in the process of recoveringfrom an error","reportError":"Report any kind of  ","sync":"This method provides the error handler with an opportunity to handle syntactic or semantic errors in the input stream before they result in a ","recoverInline":"This method is called when an unexpected symbol is encountered during an inline match operation, such as  "}},"XPathTokenElement":{"XPathTokenElement":{}},"DecisionInfo":{"DecisionInfo":{"DecisionInfo":"Constructs a new instance of the   class to containstatistics for a particular decision"}},"LexerModeAction":{"LexerModeAction":{"getActionType":"This method returns ","LexerModeAction":"Constructs a new   action with the specified mode value","getMode":"Get the lexer mode this action should transition the lexer to","isPositionDependent":"This method returns ","execute":"This action is implemented by calling   with thevalue provided by  "}},"Pair":{"Pair":{}},"ParseTreeProperty":{"ParseTreeProperty":{}},"LoopEndState":{"LoopEndState":{}},"CommonTokenStream":{"CommonTokenStream":{"CommonTokenStream":"Constructs a new   using the specified tokensource and filtering tokens to the specified channel","getNumberOfOnChannelTokens":"Count EOF just once"}},"LL1Analyzer":{"LL1Analyzer":{"_LOOK":"Compute set of tokens that can follow   in the ATN in thespecified  ","getDecisionLookahead":"Calculates the SLL(1) expected lookahead set for each outgoing transition of an  ","LOOK":"Compute set of tokens that can follow   in the ATN in thespecified  "}},"VocabularyImpl":{"VocabularyImpl":{"VocabularyImpl":"Constructs a new instance of   from the specifiedliteral, symbolic, and display token names","fromTokenNames":"Returns a   instance from the specified set of tokennames"}},"EqualityComparator":{"EqualityComparator":{"hashCode":"This method returns a hash code for the specified object","equals":"This method tests if two objects are equal"}},"BlockEndState":{"BlockEndState":{}},"FlexibleHashMap":{"FlexibleHashMap":{}},"ANTLRFileStream":{"ANTLRFileStream":{}},"RuleContextWithAltNum":{"RuleContextWithAltNum":{}},"DecisionEventInfo":{"DecisionEventInfo":{}},"RuleStartState":{"RuleStartState":{}},"IntegerStack":{"IntegerStack":{}},"LexerATNConfig":{"LexerATNConfig":{"getLexerActionExecutor":"Gets the   capable of executing the embeddedaction(s) for the current configuration"}},"ProxyErrorListener":{"ProxyErrorListener":{}},"TokenFactory":{"TokenFactory":{"create":"Generically useful  "}},"TerminalNode":{"TerminalNode":{}},"LexerCustomAction":{"LexerCustomAction":{"getRuleIndex":"Gets the rule index to use for calls to  ","getActionType":"This method returns ","getActionIndex":"Gets the action index to use for calls to  ","LexerCustomAction":"Constructs a custom lexer action with the specified rule and action indexes","isPositionDependent":"Gets whether the lexer action is position-dependent","execute":"Custom actions are implemented by calling   with theappropriate rule and action indexes"}},"LogManager":{"LogManager":{}},"IntStream":{"IntStream":{"getSourceName":"Gets the name of the underlying symbol source","size":"Returns the total number of symbols in the stream, including a single EOF symbol","LA":"Gets the value of the symbol at offset   from the currentposition","release":"This method releases a marked range created by a call to ","index":"Return the index into the stream of the input symbol referred to by ","consume":"Consumes the current symbol in the stream","seek":"Set the input cursor to the position indicated by  ","mark":"A mark provides a guarantee that   operations will bevalid over a \"marked range\" extending from the index where  was called to the current  "}},"ParseTree":{"ParseTree":{"getText":"Return the combined text of all leaf nodes","setParent":"Set the parent for this node","toStringTree":"Specialize toStringTree so that it can print out more information based upon the parser","accept":"The   needs a double dispatch method"}},"DFA":{"DFA":{"setPrecedenceDfa":"Sets whether this is a precedence DFA","getPrecedenceStartState":"Get the start state for a specific precedence value","setPrecedenceStartState":"Set the start state for a specific precedence value","toString":"Use  instead","isPrecedenceDfa":"Gets whether this DFA is a precedence DFA","getStates":"Return a list of all states in this DFA, ordered by state number"}},"EpsilonTransition":{"EpsilonTransition":{"outermostPrecedenceReturn":"the rule index of a precedence rule for which this transition isreturning from, where the precedence value is 0; otherwise, -1"}}}
